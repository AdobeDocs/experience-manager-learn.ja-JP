---
title: 資産計算ワーカーの開発
description: アセット計算ワーカーは、アセットに対して実行した作業を新しいレンディションの作成のために実行（調整）するカスタム機能を提供する、アセット計算プロジェクトの中核となります。
feature: asset-compute
topics: renditions, development
version: cloud-service
activity: develop
audience: developer
doc-type: tutorial
kt: 6282
thumbnail: KT-6282.jpg
translation-type: tm+mt
source-git-commit: af610f338be4878999e0e9812f1d2a57065d1829
workflow-type: tm+mt
source-wordcount: '1508'
ht-degree: 0%

---


# 資産計算ワーカーの開発

アセット計算ワーカーは、アセットに対して実行した作業を新しいレンディションの作成のために実行（調整）するカスタム機能を提供する、アセット計算プロジェクトの中核となります。

Asset Computeプロジェクトは、アセットの元のバイナリを名前付きのレンディションに変換せずにコピーする、単純なワーカーを自動生成します。 このチュートリアルでは、このワーカーを変更して、より興味深いレンディションを作成し、アセット計算ワーカーの能力を説明します。

新しい横置きの画像レンディションを生成するAsset Computeワーカーを作成します。横置きの画像レンディションは、アセットのレンディションの左右の空き領域をカバーし、アセットのぼやけたバージョンが適用されます。 最終的なレンディションの幅、高さおよびぼかしがパラメータ化されます。

## アセット計算ワーカー呼び出しの論理フロー

アセットコンピューティングワーカーは、概念的に次に示す関数に、Asset Compute SDKのWorker API契約を実装し `renditionCallback(...)` ます。

+ __入力：__ AEMアセットの元のアセットのバイナリとパラメーター
+ __出力：__ AEMアセットに追加する1つ以上のレンディション

![資産計算作業者の論理フロー](./assets/worker/logical-flow.png)

1. アセット計算ワーカーがAEM Authorサービスから呼び出された場合、処理プロファイルを介してAEMアセットに対して実行されます。 アセットの __(1a)__ 元のバイナリは、レンダリングコールバック関数のパラメータを介してワーカーに渡され、 `source` (1b) __(処理プロファイルでパラメータセットを介して定義された__`rendition.instructions` パラメータがすべてワーカーに渡されます。
1. Asset Compute SDKレイヤーは、処理プロファイルからの要求を受け入れ、カスタムのAsset Compute Worker `renditionCallback(...)` 関数の実行を調整し、 __(1b)が提供する任意のパラメータに基づいて(1a)______ に提供するソースバイナリを変換して、ソースバイナリのレンダリングを生成します。
   + このチュートリアルでは、レンディションが「処理中」に作成されます。つまり、ワーカーはレンディションを構成しますが、ソースバイナリはレンディションの生成用に他のWebサービスAPIにも送信できます。
1. アセット計算ワーカーは、レンディションのバイナリ表現を保存し `rendition.path` ます。これにより、レンディションはAEM Authorサービスに保存できます。
1. 完了すると、に書き込まれるバイナリデータ `rendition.path` は、Asset Compute SDKを介して転送され、AEM UIで使用できるレンディションとしてAEM Author Serviceを介して公開されます。

上の図は、Asset Compute Worker呼び出しに対する開発者向けの懸念事項と論理的な流れを示しています。 興味深い点は、Asset Computeの実行の [内部詳細を利用できる点ですが](https://docs.adobe.com/content/help/en/asset-compute/using/extend/custom-application-internals.html) 、信頼できるのはパブリックAsset Compute SDK APIの契約に限られます。

## 労働者の構造

すべてのアセットコンピューティングワーカーは、同じ基本構造と入出力契約に従います。

```javascript
'use strict';

// Any npm module imports used by the worker
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

/**
Exports the worker implemented by a custom rendition callback function, which parametrizes the input/output contract for the worker.
 + `source` represents the asset's original binary used as the input for the worker.
 + `rendition` represents the worker's output, which is the creation of a new asset rendition.
 + `params` are optional parameters, which map to additional key/value pairs, including a sub `auth` object that contains Adobe I/O access credentials.
**/
exports.main = worker(async (source, rendition, params) => {
    // Perform any necessary source (input) checks
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        // Throw appropriate errors whenever an erring condition is met
        throw new SourceCorruptError('source file is empty');
    }

    // Access any custom parameters provided via the Processing Profile configuration
    let param1 = rendition.instructions.exampleParam;

    /** 
    Perform all work needed to transform the source into the rendition.
    
    The source data can be accessed:
        + In the worker via a file available at `source.path`
        + Or via a presigned GET URL at `source.url`
    **/
    if (success) {
        // A successful worker must write some data back to `renditions.path`. 
        // This example performs a trivial 1:1 copy of the source binary to the rendition
        await fs.copyFile(source.path, rendition.path);
    } else {
        // Upon failure an Asset Compute Error (exported by @adobe/asset-compute-commons) should be thrown.
        throw new GenericError("An error occurred!", "example-worker");
    }
});

/**
Optionally create helper classes or functions the worker's rendition callback function invokes to help organize code.

Code shared across workers, or to complex to be managed in a single file, can be broken out across supporting JavaScript files in the project and imported normally into the worker. 
**/
function customHelperFunctions() { ... }
```

## ワーカーindex.jsを開く

![自動生成されたindex.js](./assets/worker/autogenerated-index-js.png)

1. VSコードでAsset Computeプロジェクトが開いていることを確認します。
1. Navigate to the `/actions/worker` folder
1. Open the `index.js` file

これは、このチュートリアルで変更するワーカーJavaScriptファイルです。

## サポートするnpmモジュールのインストールとインポート

Node.jsベースのAsset Computeプロジェクトは、堅牢な [npmモジュールエコシステムからメリットを得ています](https://npmjs.com)。 npmモジュールを活用するには、まずそれをAsset Computeプロジェクトにインストールする必要があります。

このワーカーでは、 [jimpを利用して](https://www.npmjs.com/package/jimp) 、Node.jsコードで直接レンディションの画像を作成し、操作します。

>[!WARNING]
>
>アセット操作用のnpmモジュールの一部がAsset Computeでサポートされているわけではありません。 ImageMagickやOS依存のライブラリなど、他のアプリケーションの既存のアプリケーションに依存するnpmモジュール。 JavaScript専用のnpmモジュールの使用を制限することをお勧めします。

1. アセット計算プロジェクトのルートにあるコマンドラインを開き(これは、 __ターミナル/新しいターミナルを使用してVSコードで実行できます__)、次のコマンドを実行します。

   ```
   $ npm install jimp
   ```

1. モジュールをワーカーコードにインポートし、JavaScriptオブジェクトを介して使用できるように `jimp``Jimp` します。
ワーカーの上部にある `require` ディレクティブを更新し、 `index.js` モジュールから `Jimp``jimp` オブジェクトをインポートします。

   ```javascript
   'use strict';
   
   const { Jimp } = require('jimp');
   const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
   const fs = require('fs').promises;
   
   exports.main = worker(async (source, rendition, params) => {
       // Check handle a corrupt input source
       const stats = await fs.stat(source.path);
       if (stats.size === 0) {
           throw new SourceCorruptError('source file is empty');
       }
   
       // Do work here
   });
   ```

## パラメーターの読み取り

アセットコンピューティングワーカーは、AEMでCloud Service作成者サービスとして定義された処理プロファイルー経由で渡すことのできるパラメーターを読み取ることができます。 パラメータは、 `rendition.instructions` オブジェクトを介してワーカーに渡されます。

これらは、ワーカーコード内のにアクセスするこ `rendition.instructions.<parameterName>` とで読み取ることができます。

ここでは、設定可能なレンディションを読み込み `SIZE`、処理プロファイルで指定され `BRIGHTNESS``CONTRAST`ていない場合はデフォルト値を指定します。 AEMから呼び出された場合 `renditions.instructions` は、文字列としてCloud Service処理プロファイルとして渡されるので、ワーカーコード内の正しいデータ型に変換されていることを確認してください。

```javascript
'use strict';

const { Jimp } = require('jimp');
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    // Processing Profiles pass in instructions as Strings, so make sure to parse to correct data types
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    // Do work here
}
```

## エラーのスロー{#errors}

アセットコンピューティングワーカーは、エラーを引き起こす状況に直面する場合があります。 Adobeアセット計算SDKは、事前 [に定義されたエラーのスイートを提供します](https://github.com/adobe/asset-compute-commons#asset-compute-errors) 。これらのエラーは、このような状況が発生した場合にスローされる可能性があります。 特定のエラータイプが適用されない場合は、を使用す `GenericError` るか、特定のカスタムを定義 `ClientErrors` できます。

レンディションの処理を開始する前に、このワーカーのコンテキストで、すべてのパラメーターが有効でサポートされていることを確認してください。

+ 、、のレンディション指示パラメーター `SIZE`が有効であるこ `CONTRAST`と `BRIGHTNESS` を確認します。 そうでない場合は、カスタムエラーをスローし `RenditionInstructionsError`ます。
   + 拡張するカスタム `RenditionInstructionsError` クラス `ClientError` は、このファイルの一番下に定義されます。 特定のカスタムエラーを使用すると、ワーカーのテストを [作成する場合に役立ちます](../test-debug/test.md) 。

```javascript
'use strict';

const { Jimp } = require('jimp');
// Import the Asset Compute SDK provided `ClientError` 
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        // Ensure size is within allowable bounds
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Do work here
}

// Create a new ClientError to handle invalid rendition.instructions values
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        // Provide a:
        // + message: describing the nature of this erring condition
        // + name: the name of the error; usually same as class name
        // + reason: a short, searchable, unique error token that identifies this error
        super(message, "RenditionInstructionsError", "rendition_instructions_error");

        // Capture the strack trace
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## レンディションの作成

読み取ったパラメーターに基づいて、分析と検証が行われ、コードが書き込まれてレンディションが生成されます。 レンディションの生成に使用する擬似コードは、次のとおりです。

1. パラメーターで指定した正方形のサイズで新しい `renditionImage` キャンバスを作成し `size` ます。
1. ソースアセットのバイナリから `image` オブジェクトを作成する
1. Jimp ____ ライブラリを使用して画像を変換します。
   + 元の画像を中央に配置した正方形に切り抜く
   + 「角ばった」画像の中心から円を切り取る
   + パラメータ値で定義された寸法内に収まるように `SIZE` 拡大縮小
   + パラメータ値に基づいてコントラストを調整 `CONTRAST` する
   + パラメータ値に基づいて明るさを調整する `BRIGHTNESS`
1. 透明な背景 `image` を持つのの中央に変換 `renditionImage` したものを配置します
1. アセットレンディション `renditionImage``rendition.path` としてAEMに再び保存できるように、組版を書き込みます。

このコードでは、 [Jimp APIを使用して](https://github.com/oliver-moran/jimp#jimp) 、これらの画像変換を実行します。

アセット計算ワーカーは、作業を同期的に終了し、ワーカーの `rendition.path``renditionCallback` 完了前に完全に書き戻す必要があります。 このためには、非同期関数の呼び出しを、 `await` 演算子を使用して同期化する必要があります。 JavaScriptの非同期関数と同期的に実行する方法に詳しくない場合は、JavaScriptのawait演算子を理解して [ください](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)。

完成した作業者は、次のよう `index.js` になります。

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        throw new RenditionInstructionsError("'size' must be between 10 and 10,000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Create target rendition image of the target size with a transparent background (0x0)
    let renditionImage =  new Jimp(SIZE, SIZE, 0x0);

    // Read and perform transformations on the source binary image
    let image = await Jimp.read(source.path);

    // Crop a circle from the source asset, and then apply contrast and brightness using Jimp
    image.crop(
            image.bitmap.width < image.bitmap.height ? 0 : (image.bitmap.width - image.bitmap.height) / 2,
            image.bitmap.width < image.bitmap.height ? (image.bitmap.height - image.bitmap.width) / 2 : 0,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height
        )   
        .circle()
        .scaleToFit(SIZE, SIZE)
        .contrast(CONTRAST)
        .brightness(BRIGHTNESS);

    // Place the transformed image onto the transparent renditionImage to save as PNG
    renditionImage.composite(image, 0, 0)

    // Write the final transformed image to the asset's rendition
    renditionImage.write(rendition.path);
});

// Custom error used for renditions.instructions parameter checking
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        super(message, "RenditionInstructionsError", "rendition_instructions_error");
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## ワーカーの実行

これでワーカーコードが完了し、以前に [manifest.ymlに登録および設定されたので](./manifest.md)、ローカルのAsset Compute Development Toolを使用して実行し、結果を確認できます。

1. アセット計算プロジェクトのルートから
1. 実行 `app aio run`
1. アセット計算開発ツールが新しいウィンドウで開くのを待つ
1. 「 __Select a file...__ 」ドロップダウンで、処理するサンプル画像を選択します。
   + ソースアセットのバイナリとして使用するサンプル画像ファイルを選択します
   + まだ存在しない場合は、左 __側の__ (+) [をタップし、](../assets/samples/sample-file.jpg) サンプル画像ファイルをアップロードして、開発ツールブラウザーウィンドウを更新します
1. このワーカ `"name": "rendition.png"` ーを更新して、透明なPNGを生成します。
   + この「name」パラメーターは開発ツールでのみ使用され、使用しないでください。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png"
           }
       ]
   }
   ```
1. 「 __実行__ 」をタップし、レンディションが生成されるのを待ちます。
1. 「 __レンディション__ 」セクションには、生成されたレンディションがプレビューされます。 レンディションのプレビューをタップして、完全なレンディションをダウンロードします

   ![デフォルトのPNGレンディション](./assets/worker/default-rendition.png)

### パラメータを使用して作業者を実行

処理プロファイル設定を介して渡されるパラメーターは、レンディションパラメーターJSONにキー/値のペアとして指定することで、アセット計算開発ツールでシミュレートできます。

>[!WARNING]
>
>ローカル開発では、AEMからCloud Service処理プロファイルーとして渡された値を文字列として様々なデータ型を使用して渡すことができるので、必要に応じて正しいデータ型が解析されることを確認します。
> 例えば、Jimpの関数では、パラメーターが「s」である必要があ `crop(width, height)``int`ります。int `parseInt(rendition.instructions.size)` に解析されない場合、パラメーターの型に互換性がないため、への呼び出し `jimp.crop(SIZE, SIZE)` は失敗します。

コードは次のパラメーターを受け付けます。

+ `size` レンディションのサイズを定義します（高さと幅を整数で指定）。
+ `contrast` コントラストの調整を定義します。-1 ～ 1の範囲で指定する必要があります。
+ `brightness`  明るい調整を定義します。浮動小数点として、-1 ～ 1の範囲で設定する必要があります

これらは、次を介してワーカーで読み取ら `index.js` れます。

+ `const SIZE = parseInt(rendition.instructions.size) || 800`
+ `const CONTRAST = parseFloat(rendition.instructions.contrast) || 0`
+ `const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0`

1. レンディションのパラメータを更新して、サイズ、コントラスト、明るさをカスタマイズします。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png",
               "size": "450",
               "contrast": "0.30",
               "brightness": "0.15"
           }
       ]
   }
   ```

1. 「 __実行__ 」を再度タップします
1. レンディションプレビューをタップして、生成されたレンディションをダウンロードし、確認します。 初期設定のレンディションと比較して、サイズと、コントラストと明るさが変更されたことを確認します。

   ![パラメータ化PNGレンディション](./assets/worker/parameterized-rendition.png)

1. 他の画像を「 __ソースファイル__ 」ドロップダウンにアップロードし、異なるパラメータでワーカーを実行してみてください。

## GithubのWorker index.js

最終版 `index.js` は次の場所でGithubで入手できます。

+ [aem-guides-wknd-asset-compute/actions/worker/index.js](https://github.com/adobe/aem-guides-wknd-asset-compute/blob/master/actions/worker/index.js)

## トラブルシューティング

### レンディションが部分的に描画されて返される

+ __エラー__:レンディションのファイルサイズの合計が大きい場合、レンディションが完全にレンダリングされません

   ![トラブルシューティング — レンディションが部分的に描画されて返される](./assets/worker/troubleshooting__await.png)

+ __原因__:レンディションの書き込みが完了する前に、ワーカーの `renditionCallback` 機能を終了してい `rendition.path`ます。
+ __解像度__:カスタムワーカーコードを確認し、すべての非同期呼び出しが同期されていることを確認します。
