---
title: asset computeワーカーの開発
description: asset compute作業者は、アセットに対して実行した作業を新しいレンディションの作成のために実行、または調整するカスタム機能を提供する、Asset computeプロジェクトの中核となります。
feature: asset computeマイクロサービス
topics: renditions, development
version: cloud-service
activity: develop
audience: developer
doc-type: tutorial
kt: 6282
thumbnail: KT-6282.jpg
topic: 統合、開発
role: Developer
level: Intermediate, Experienced
translation-type: tm+mt
source-git-commit: 1e5d8171832ec6b26969a8485ae970e295962828
workflow-type: tm+mt
source-wordcount: '1426'
ht-degree: 0%

---


# asset computeワーカーの開発

asset compute作業者は、アセットに対して実行した作業を新しいレンディションの作成のために実行、または調整するカスタム機能を提供する、Asset computeプロジェクトの中核となります。

asset computeプロジェクトは、アセットの元のバイナリを名前付きのレンディションに変換せずにコピーする、単純なワーカーを自動生成します。 このチュートリアルでは、このワーカーを変更して、Asset computeワーカーの能力を説明する、より興味深いレンディションを作成します。

ここでは、新しい横置きのAsset computeレンディションを生成するイメージワーカーを作成します。横置きの画像レンディションは、アセットのレンディションの左右の空き領域をカバーし、アセットのぼやけたバージョンを含みます。 最終的なレンディションの幅、高さおよびぼかしがパラメータ化されます。

## asset computeワーカー呼び出しの論理フロー

asset computeワーカーは、Asset computeSDKのワーカーAPI契約を`renditionCallback(...)`関数に実装します。この関数は概念上次のとおりです。

+ __入力：AEMアセット__ の元のバイナリパラメーターと処理プロファイルパラメーター
+ __出力：AEMアセットに追加する1つ__ 以上のレンディション

![asset compute作業者の論理フロー](./assets/worker/logical-flow.png)

1. AEM AuthorサービスはAsset computeワーカーを呼び出し、アセットの&#x200B;__(1a)__&#x200B;元のバイナリ（`source`パラメーター）と&#x200B;__(1b)__&#x200B;に、処理プロファイル（`rendition.instructions`パラメーター）で定義されているパラメーターを指定します。
1. asset computeSDKは、カスタムAsset computeメタデータワーカーの`renditionCallback(...)`関数の実行を調整し、アセットの元のバイナリ&#x200B;__(1a)__&#x200B;とパラメータ&#x200B;__(1b)__&#x200B;に基づいて新しいバイナリレンディションを生成します。

   + このチュートリアルでは、レンディションが「処理中」に作成されます。つまり、ワーカーはレンディションを構成しますが、ソースバイナリはレンディションの生成用に他のWebサービスAPIにも送信できます。

1. asset computeワーカーは、新しいレンディションのバイナリデータを`rendition.path`に保存します。
1. `rendition.path`に書き込まれたバイナリデータは、Asset computeSDKを介してAEM Author Serviceに転送され、__(4a)__&#x200B;としてアセットのメタデータノードに公開されます。__(4b)__&#x200B;は持続します。

上の図は、Asset compute開発者が直面する懸念事項と、Asset computeワーカーの呼び出しへの論理的な流れを示しています。 興味深い点は、[Asset compute実行の内部詳細](https://docs.adobe.com/content/help/en/asset-compute/using/extend/custom-application-internals.html)を入手できる点ですが、信頼できるのはパブリックAsset computeSDK APIの契約に限られます。

## 労働者の構造

すべてのAsset computeワーカーは、同じ基本構造と入出力契約に従います。

```javascript
'use strict';

// Any npm module imports used by the worker
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

/**
Exports the worker implemented by a custom rendition callback function, which parametrizes the input/output contract for the worker.
 + `source` represents the asset's original binary used as the input for the worker.
 + `rendition` represents the worker's output, which is the creation of a new asset rendition.
 + `params` are optional parameters, which map to additional key/value pairs, including a sub `auth` object that contains Adobe I/O access credentials.
**/
exports.main = worker(async (source, rendition, params) => {
    // Perform any necessary source (input) checks
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        // Throw appropriate errors whenever an erring condition is met
        throw new SourceCorruptError('source file is empty');
    }

    // Access any custom parameters provided via the Processing Profile configuration
    let param1 = rendition.instructions.exampleParam;

    /** 
    Perform all work needed to transform the source into the rendition.
    
    The source data can be accessed:
        + In the worker via a file available at `source.path`
        + Or via a presigned GET URL at `source.url`
    **/
    if (success) {
        // A successful worker must write some data back to `renditions.path`. 
        // This example performs a trivial 1:1 copy of the source binary to the rendition
        await fs.copyFile(source.path, rendition.path);
    } else {
        // Upon failure an Asset Compute Error (exported by @adobe/asset-compute-commons) should be thrown.
        throw new GenericError("An error occurred!", "example-worker");
    }
});

/**
Optionally create helper classes or functions the worker's rendition callback function invokes to help organize code.

Code shared across workers, or to complex to be managed in a single file, can be broken out across supporting JavaScript files in the project and imported normally into the worker. 
**/
function customHelperFunctions() { ... }
```

## ワーカーindex.jsを開く

![自動生成されたindex.js](./assets/worker/autogenerated-index-js.png)

1. asset computeプロジェクトがVSコードで開いていることを確認します。
1. `/actions/worker`フォルダーに移動します
1. `index.js`ファイルを開きます

これは、このチュートリアルで変更するワーカーJavaScriptファイルです。

## サポートするnpmモジュールのインストールとインポート

Node.jsベースのAsset computeプロジェクトは、堅牢な[npm module ecosystem](https://npmjs.com)を活用しています。 npmモジュールを活用するには、まずAsset computeプロジェクトにモジュールをインストールする必要があります。

このワーカーでは、[jimp](https://www.npmjs.com/package/jimp)を利用して、Node.jsコードで直接レンディションの画像を作成し、操作します。

>[!WARNING]
>
>アセット操作用のnpmモジュールの中には、Asset computeでサポートされていないものもあります。 ImageMagickなどのアプリケーションや、OSに依存する他のライブラリの存在に依存するnpmモジュールはサポートされていません。 JavaScript専用のnpmモジュールの使用を制限することをお勧めします。

1. asset computeプロジェクトのルートにあるコマンドラインを開き（__ターミナル>新しいターミナル__&#x200B;を介してVSコードで実行できます）、次のコマンドを実行します。

   ```
   $ npm install jimp
   ```

1. `jimp`モジュールをワーカーコードにインポートし、`Jimp` JavaScriptオブジェクトを介して使用できるようにします。
ワーカーの`index.js`の上部にある`require`ディレクティブを更新し、`jimp`モジュールから`Jimp`オブジェクトをインポートします。

   ```javascript
   'use strict';
   
   const Jimp = require('jimp');
   const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
   const fs = require('fs').promises;
   
   exports.main = worker(async (source, rendition, params) => {
       // Check handle a corrupt input source
       const stats = await fs.stat(source.path);
       if (stats.size === 0) {
           throw new SourceCorruptError('source file is empty');
       }
   
       // Do work here
   });
   ```

## パラメーターの読み取り

asset compute作業者は、AEMでCloud Service作成者サービスとして定義された処理プロファイルー経由で渡すことのできるパラメーターを読み取ることができます。 パラメーターは、`rendition.instructions`オブジェクトを介してワーカーに渡されます。

これらは、ワーカーコードの`rendition.instructions.<parameterName>`にアクセスすることで読み取ることができます。

ここでは、設定可能なレンディションの`SIZE`、`BRIGHTNESS`、`CONTRAST`を読み込み、処理プロファイルを介して何も指定されていない場合はデフォルト値を指定します。 AEMからCloud Service処理プロファイルとして呼び出された場合、`renditions.instructions`は文字列として渡されるので、ワーカーコード内の正しいデータ型に変換されていることを確認してください。

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    // Processing Profiles pass in instructions as Strings, so make sure to parse to correct data types
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    // Do work here
}
```

## エラーをスロー{#errors}

asset computeワーカーは、エラーを引き起こす状況に直面する場合があります。 AdobeAsset computeSDKは、[事前に定義されたエラー](https://github.com/adobe/asset-compute-commons#asset-compute-errors)のスイートを提供します。これらのエラーは、このような状況が発生した場合にスローされます。 特定のエラータイプが適用されない場合は、`GenericError`を使用するか、特定のカスタム`ClientErrors`を定義できます。

レンディションの処理を開始する前に、このワーカーのコンテキストで、すべてのパラメーターが有効でサポートされていることを確認してください。

+ `SIZE`、`CONTRAST`および`BRIGHTNESS`のレンディションの指示パラメーターが有効であることを確認します。 そうでない場合は、カスタムエラー`RenditionInstructionsError`をスローします。
   + `ClientError`を拡張するカスタム`RenditionInstructionsError`クラスは、このファイルの末尾で定義されます。 特定のカスタムエラーを使用すると、ワーカーの[書き込みテスト](../test-debug/test.md)を行う場合に役立ちます。

```javascript
'use strict';

const Jimp = require('jimp');
// Import the Asset Compute SDK provided `ClientError` 
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read in parameters and set defaults if parameters are provided
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        // Ensure size is within allowable bounds
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        // Ensure contrast is valid value
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Do work here
}

// Create a new ClientError to handle invalid rendition.instructions values
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        // Provide a:
        // + message: describing the nature of this erring condition
        // + name: the name of the error; usually same as class name
        // + reason: a short, searchable, unique error token that identifies this error
        super(message, "RenditionInstructionsError", "rendition_instructions_error");

        // Capture the strack trace
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## レンディションの作成

読み取ったパラメーターに基づいて、分析と検証が行われ、コードが書き込まれてレンディションが生成されます。 レンディションの生成に使用する擬似コードは、次のとおりです。

1. `size`パラメーターで指定した正方形の寸法で新しい`renditionImage`キャンバスを作成します。
1. ソースアセットのバイナリから`image`オブジェクトを作成
1. __Jimp__&#x200B;ライブラリを使用して画像を変換します。
   + 元の画像を中央に配置した正方形に切り抜く
   + 「角ばった」画像の中心から円を切り取る
   + `SIZE`パラメーター値で定義された寸法内に合わせて拡大縮小
   + `CONTRAST`パラメーターの値に基づいてコントラストを調整
   + `BRIGHTNESS`パラメーターの値に基づいて明るさを調整
1. 透明な背景を持つ`image`の中央に変換後の`renditionImage`を配置します
1. 組版済みの`renditionImage`を`rendition.path`に書き込み、AEMにアセットのレンディションとして保存し直すことができます。

このコードは、[Jimp API](https://github.com/oliver-moran/jimp#jimp)を使用して、これらの画像変換を実行します。

asset computeワーカーは同期的に作業を終了し、`rendition.path`は、ワーカーの`renditionCallback`が完了する前に完全に書き戻す必要があります。 これには、`await`演算子を使用して非同期関数呼び出しを同期させる必要があります。 JavaScriptの非同期関数と同期的に実行する方法に詳しくない場合は、[JavaScriptのawait演算子](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)を理解してください。

完成したワーカー`index.js`は、次のようになります。

```javascript
'use strict';

const Jimp = require('jimp');
const { worker, SourceCorruptError, ClientError } = require('@adobe/asset-compute-sdk');
const fs = require('fs').promises;

exports.main = worker(async (source, rendition, params) => {
    const stats = await fs.stat(source.path);
    if (stats.size === 0) {
        throw new SourceCorruptError('source file is empty');
    }

    // Read/parse and validate parameters
    const SIZE = parseInt(rendition.instructions.size) || 800; 
    const CONTRAST = parseFloat(rendition.instructions.contrast) || 0;
    const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0;

    if (SIZE <= 10 || SIZE >= 10000) {
        throw new RenditionInstructionsError("'size' must be between 10 and 1,0000");
    } else if (CONTRAST <= -1 || CONTRAST >= 1) {
        throw new RenditionInstructionsError("'contrast' must between -1 and 1");
    } else if (BRIGHTNESS <= -1 || BRIGHTNESS >= 1) {
        throw new RenditionInstructionsError("'brightness' must between -1 and 1");
    }

    // Create target rendition image 
    let renditionImage =  new Jimp(SIZE, SIZE, 0x0);

    // Read and perform transformations on the source binary image
    let image = await Jimp.read(source.path);

    // Crop a circle from the source asset, and then apply contrast and brightness
    image.crop(
            image.bitmap.width < image.bitmap.height ? 0 : (image.bitmap.width - image.bitmap.height) / 2,
            image.bitmap.width < image.bitmap.height ? (image.bitmap.height - image.bitmap.width) / 2 : 0,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height,
            image.bitmap.width < image.bitmap.height ? image.bitmap.width : image.bitmap.height
        )   
        .circle()
        .scaleToFit(SIZE, SIZE)
        .contrast(CONTRAST)
        .brightness(BRIGHTNESS);

    // Place the transformed image onto the transparent renditionImage to save as PNG
    renditionImage.composite(image, 0, 0)

    // Write the final transformed image to the asset's rendition
    await renditionImage.writeAsync(rendition.path);
});

// Custom error used for renditions.instructions parameter checking
class RenditionInstructionsError extends ClientError {
    constructor(message) {
        super(message, "RenditionInstructionsError", "rendition_instructions_error");
        Error.captureStackTrace(this, RenditionInstructionsError);
    }
}
```

## ワーカーの実行

ワーカーコードが完了し、以前に[manifest.yml](./manifest.md)に登録および設定されたので、ローカルAsset compute開発ツールを使用して実行し、結果を確認できます。

1. asset computeプロジェクトのルートから
1. 実行 `aio app run`
1. asset compute開発ツールが新しいウィンドウで開くのを待つ
1. __ファイルを選択…__&#x200B;ドロップダウンで、処理するサンプル画像を選択
   + ソースアセットのバイナリとして使用するサンプル画像ファイルを選択します
   + まだ存在しない場合は、左側の&#x200B;__(+)__&#x200B;をタップし、[サンプル画像](../assets/samples/sample-file.jpg)ファイルをアップロードして、開発ツールのブラウザーウィンドウを更新します
1. `"name": "rendition.png"`をこのワーカーとして更新し、透明なPNGを生成します。
   + この「name」パラメーターは開発ツールでのみ使用され、使用しないでください。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png"
           }
       ]
   }
   ```
1. 「__実行__」をタップし、レンディションが生成されるのを待ちます
1. __レンディション__&#x200B;セクションには、生成されたレンディションがプレビューされます。 レンディションのプレビューをタップして、完全なレンディションをダウンロードします

   ![デフォルトのPNGレンディション](./assets/worker/default-rendition.png)

### パラメータを使用して作業者を実行

処理プロファイルー設定を介して渡されるパラメーターは、レンディションパラメーターJSONにキー/値のペアとして提供することで、Asset compute開発ツールでシミュレートできます。

>[!WARNING]
>
>ローカル開発時に、AEMからCloud Service処理プロファイルーとして渡される場合、様々なデータ型を使用して値を渡すことができます。したがって、必要に応じて正しいデータ型が解析されることを確認してください。
> 例えば、Jimpの`crop(width, height)`関数のパラメーターは`int`である必要があります。`parseInt(rendition.instructions.size)`がintで解析されない場合、`jimp.crop(SIZE, SIZE)`の呼び出しは失敗します。パラメーターの型に互換性がないためです。

コードは次のパラメーターを受け付けます。

+ `size` レンディションのサイズを定義します（高さと幅を整数で指定）。
+ `contrast` コントラストの調整を定義します。-1 ～ 1の範囲で指定する必要があります。
+ `brightness`  明るい調整を定義します。浮動小数点として、-1 ～ 1の範囲で設定する必要があります

これらは、次を介してワーカー`index.js`で読み取られます。

+ `const SIZE = parseInt(rendition.instructions.size) || 800`
+ `const CONTRAST = parseFloat(rendition.instructions.contrast) || 0`
+ `const BRIGHTNESS = parseFloat(rendition.instructions.brightness) || 0`

1. レンディションのパラメータを更新して、サイズ、コントラスト、明るさをカスタマイズします。

   ```json
   {
       "renditions": [
           {
               "worker": "...",
               "name": "rendition.png",
               "size": "450",
               "contrast": "0.30",
               "brightness": "0.15"
           }
       ]
   }
   ```

1. 「__実行__」をもう一度タップします
1. レンディションプレビューをタップして、生成されたレンディションをダウンロードし、確認します。 初期設定のレンディションと比較して、サイズと、コントラストと明るさが変更されたことを確認します。

   ![パラメータ化PNGレンディション](./assets/worker/parameterized-rendition.png)

1. 他の画像を&#x200B;__ソースファイル__&#x200B;ドロップダウンにアップロードし、異なるパラメーターでワーカーを実行してみてください。

## GithubのWorker index.js

最終版`index.js`はGithubで次の場所で入手できます。

+ [aem-guides-wknd-asset-compute/actions/worker/index.js](https://github.com/adobe/aem-guides-wknd-asset-compute/blob/master/actions/worker/index.js)

## トラブルシューティング

+ [レンディションが部分的に描画または破損して返されました](../troubleshooting.md#rendition-returned-partially-drawn-or-corrupt)
