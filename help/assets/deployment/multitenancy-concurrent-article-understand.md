---
title: マルチテナント機能と同時開発について
description: Adobe Experience Manager Assets を使用したマルチテナント実装を管理するメリット、課題、テクニックについて説明します。
feature: Connected Assets
version: 6.5
topic: Development
role: Developer
level: Intermediate
exl-id: c9ee29d4-a8a5-4e61-bc99-498674887da5
source-git-commit: b069d958bbcc40c0079e87d342db6c5e53055bc7
workflow-type: tm+mt
source-wordcount: '2017'
ht-degree: 0%

---

# マルチテナント機能と同時開発について {#understanding-multitenancy-and-concurrent-development}

## はじめに {#introduction}

複数のチームが同じAEM環境にコードをデプロイする場合、他のチームの足を踏み入れることなく、可能な限り独立してチームが作業できるようにする必要があるプラクティスがあります。 完全に削除することはできませんが、これらのテクニックは、チーム間の依存関係を最小限に抑えます。 同時開発モデルを成功させるには、開発チーム間の良好なコミュニケーションが重要です。

さらに、複数の開発チームが同じAEM環境で作業する場合、ある程度のマルチテナント性が生じる可能性が高くなります。 AEM環境で複数のテナントをサポートしようとする際の実践的な検討事項、特にガバナンス、運用、開発を管理する際に直面する課題に関しては、多くの点が書かれています。 この論文では、マルチテナント環境でのAEMの実装に関する技術的な課題の一部を紹介しますが、これらの推奨事項の多くは、複数の開発チームを持つ組織に適用されます。

AEMは、1 つの環境に複数のサイトや複数のブランドをデプロイできるのに対し、真のマルチテナント機能を提供しないという点を事前に理解しておくことが重要です。 一部の環境設定およびシステムリソースは、環境にデプロイされているすべてのサイトで常に共有されます。 この論文では、これらの共有リソースの影響を最小限に抑えるためのガイダンスを提供し、これらの分野でのコミュニケーションと共同作業を合理化するための提案を提供します。

## メリットと課題 {#benefits-and-challenges}

マルチテナント環境の実装には、多くの課題があります。

次の機能が含まれます。

* 技術的な複雑さの追加
* 開発のオーバーヘッドの増加
* 共有リソースへの組織間の依存関係
* 運用の複雑さの増大

直面している課題にもかかわらず、マルチテナントアプリケーションを実行すると次のような利点があります。

* ハードウェアコストの削減
* 将来のサイトの市場投入までの時間を短縮
* 将来のテナントの実装コストを削減
* ビジネス全体にわたる標準的なアーキテクチャと開発プラクティス
* 共通のコードベース

ビジネスが真のマルチテナント機能を必要とし、他のテナントの知識がなく、共有コード、コンテンツ、一般的な作成者がいない場合は、個別のオーサーインスタンスが実行可能な唯一のオプションです。 開発作業の全体的な増加は、インフラストラクチャとライセンスコストの削減と比較して、このアプローチが最適な方法かどうかを判断する必要があります。

## 開発テクニック {#development-techniques}

### 依存関係の管理 {#managing-dependencies}

Maven プロジェクトの依存関係を管理する場合、すべてのチームがサーバー上の特定の OSGi バンドルの同じバージョンを使用することが重要です。 Maven プロジェクトの管理が誤っている場合に何が起こるかを説明するために、次の例を示します。

プロジェクト A はライブラリのバージョン 1.0(foo;) に依存します。foo バージョン 1.0 は、サーバーへのデプロイメントに埋め込まれます。 プロジェクト B はライブラリのバージョン 1.1、foo；に依存します。foo version 1.1 は、デプロイメントに埋め込まれます。

さらに、このライブラリで API がバージョン 1.0 と 1.1 の間で変更されたとします。この時点で、これら 2 つのプロジェクトの 1 つが正しく動作しなくなります。

この問題に対処するために、すべての Maven プロジェクトを 1 つの親リアクタープロジェクトの子にすることをお勧めします。 このリアクタプロジェクトは、次の 2 つの目的を果たします。必要に応じて、すべてのプロジェクトの構築とデプロイを一緒に行うことができ、すべての子プロジェクトの依存関係宣言が含まれます。 親プロジェクトは依存関係とそのバージョンを定義し、子プロジェクトは必要な依存関係のみを宣言し、親プロジェクトからバージョンを継承します。

このシナリオでは、プロジェクト B で作業しているチームが foo のバージョン 1.1 の機能を必要とする場合、開発環境では、この変更によってプロジェクト A が壊れることがすぐに明らかになります。この時点で、チームはこの変更について話し合い、プロジェクト A を新しいバージョンと互換性を持たせるか、プロジェクト B の代替ソリューションを探すことができます。

これにより、これらのチームがこの依存関係を共有する必要がなくなるわけではありません。単に問題を迅速かつ早期に強調するだけで、チームはリスクについて話し合い、ソリューションについて合意できます。

### コードの重複の防止 {#preventing-code-duplication-nbsp-br}

複数のプロジェクトで作業する場合は、コードが重複しないようにすることが重要です。 コードの複製により、欠陥の発生の可能性、システムの変更に伴うコスト、コードベース内の全体的な剛性が高まります。 重複を防ぐために、共通ロジックを、複数のプロジェクトで使用できる再利用可能なライブラリにリファクタリングします。

このニーズに対応するために、すべてのチームが依存し、貢献できるコアプロジェクトの開発とメンテナンスをお勧めします。 その際は、このコアプロジェクトが個々のチームのプロジェクトに依存しないようにすることが重要です。これにより、コードの再利用を促進しながら、独立したデプロイメントを可能にします。

コアモジュールで一般的に使用されるコードの例を以下に示します。

* 次のようなシステム全体の構成
   * OSGi 設定
   * サーブレットフィルター
   * ResourceResolver のマッピング
   * Sling 変換サービスパイプライン
   * エラーハンドラー ( または ACS AEM Commons Error Page Handler1 を使用 )
   * 権限を区別するキャッシュ用の認証サーブレット
* ユーティリティクラス
* コアビジネスロジック
* サードパーティ統合ロジック
* UI オーバーレイのオーサリング
* カスタムウィジェットなど、オーサリングに必要なその他のカスタマイズ
* ワークフローランチャー
* サイト全体で使用される一般的なデザイン要素

*モジュラー型プロジェクトアーキテクチャ*

これにより、複数のチームが依存し、同じコードセットを更新する必要がなくなるわけではありません。 コアプロジェクトを作成することで、チーム間で共有されるコードベースのサイズが小さくなりましたが、共有リソースは不要になりました。

このコアパッケージに加えた変更がシステムの機能を妨げないように、シニアデベロッパーまたはデベロッパーチームが管理を維持することをお勧めします。 選択肢の 1 つは、このパッケージに対するすべての変更を管理する 1 つのチームを持つことです。もう 1 つは、チームに、これらのリソースで確認されマージされたプル要求を送信させることです。 ガバナンスモデルは、チームが設計し、それに従って開発者が合意することが重要です。

## デプロイメント範囲の管理  {#managing-deployment-scope}

異なるチームが同じリポジトリにコードをデプロイするので、互いの変更が上書きされないようにすることが重要です。 AEMは、コンテンツパッケージ（フィルター）をデプロイする際にこれを制御するメカニズムを備えています。 xml ファイル。 フィルター間に重複がないことが重要です。  xml ファイルを使用する場合、あるチームのデプロイメントによって、別のチームの以前のデプロイメントが削除される可能性があります。 この点を説明するために、次のような適切に作成されたフィルタファイルと問題のあるフィルタファイルの例を参照してください。

/apps/my-company と/apps/my-company/my-site

/etc/clientlibs/my-company との比較/etc/clientlibs/my-company/my-site

/etc/designs/my-company と/etc/designs/my-company/my-site

各チームが作業中のサイトに対してフィルターファイルを明示的に設定する場合、各チームは、互いの変更を消去することなく、コンポーネント、クライアントライブラリ、サイトデザインを個別に展開できます。

これはグローバルシステムパスで、1 つのサイトに固有ではないので、ここでの変更はチームに影響を与える可能性があるので、次のサーブレットをコアプロジェクトに含める必要があります。

/apps/sling/servlet/errorhandler

### オーバーレイ {#overlays}

オーバーレイは、標準のAEM機能を拡張または置き換えるために頻繁に使用されますが、オーバーレイを使用するとAEMアプリケーション全体に影響します（つまり、オーバーレイされた機能の変更はすべてのテナントで利用可能になります）。 テナントがオーバーレイの要件を異にした場合、これはさらに複雑になります。 ビジネスグループが連携して、AEM管理コンソールの機能と外観に合意するのが理想です。

様々なビジネスユニットの間でコンセンサスが得られない場合、考えられる解決策は、単にオーバーレイを使用しないことです。 代わりに、機能のカスタムコピーを作成し、テナントごとに異なるパスを使用して公開します。 これにより、各テナントのユーザーエクスペリエンスが完全に異なりますが、この方法を使用すると、実装コストとその後のアップグレード作業のコストも増加します。

### ワークフローランチャー {#workflow-launchers}

AEMでは、リポジトリで指定した変更がおこなわれた場合、ワークフローランチャーを使用して、ワークフローの実行を自動的にトリガーします。 AEMには、例えば、新しいアセットや更新されたアセットに対してレンディションの生成とメタデータの抽出プロセスを実行するための、いくつかのランチャーが標準で用意されています。 マルチテナント環境では、これらのランチャーをそのままの状態にしておくことは可能ですが、テナントにランチャーやワークフローモデルの要件が異なる場合は、テナントごとに個々のランチャーを作成し管理する必要が生じます。 他のテナントのコンテンツを変更しないまま、これらのランチャーがテナントの更新で実行するように設定する必要があります。 これを簡単に実現するには、テナント固有の指定されたリポジトリパスにランチャーを適用します。

### バニティー URL {#vanity-urls}

AEMには、ページごとに設定できるバニティー URL 機能が用意されています。 マルチテナントシナリオでのこのアプローチでの懸念事項は、AEMがこの方法で設定されたバニティー URL 間での一意性を保証しないことです。 2 人の異なるユーザーが異なるページに同じバニティーパスを設定している場合、予期しない動作が発生する可能性があります。 このため、Apache Dispatcher インスタンスでは mod_rewrite ルールを使用することをお勧めします。このルールでは、アウトバウンドのみの Resource Resolver ルールと連携して設定の中心点を確保できます。

### コンポーネントグループ {#component-groups}

複数のオーサリンググループ用のコンポーネントやテンプレートを開発する場合は、componentGroup プロパティと allowedPaths プロパティを有効に使用することが重要です。 これらをサイトデザインと共に効果的に活用することで、ブランド A の作成者はサイト用に作成されたコンポーネントやテンプレートのみを表示でき、ブランド B の作成者は自分のコンポーネントやテンプレートのみを表示できます。

### テスト {#testing}

優れたアーキテクチャとオープンな通信チャネルは、サイトの予期しない領域に欠陥が導入されるのを防ぐのに役立ちますが、これらのアプローチは無害です。 このため、何が実稼動環境にリリースされる前に、プラットフォームにデプロイされているかを完全にテストしておくことが重要です。 これには、リリースサイクルでチーム間の調整が必要です。また、可能な限り多くの機能をカバーする自動テストのスイートの必要性が強化されます。 さらに、1 つのシステムが複数のチームで共有されるので、パフォーマンス、セキュリティ、負荷テストはこれまで以上に重要になります。

## 運用上の考慮事項 {#operational-considerations}

### 共有リソース {#shared-resources}

AEMは単一の JVM 内で実行されます。デプロイ済みのAEMアプリケーションは、AEMの通常の実行で既に使用されているリソースに加えて、本質的にリソースを相互に共有します。 JVM 領域自体には、スレッドの論理的な分離はなく、AEMで使用可能な有限リソース（メモリ、CPU、ディスク I/O など）も共有されます。 リソースを消費するテナントは、必然的に他のシステムテナントに影響を与えます。

### パフォーマンス {#performance}

AEMのベストプラクティスに従わない場合は、通常と見なされる以上にリソースを消費するアプリケーションを開発できます。 この例としては、多くの重いワークフロー操作（DAM の更新アセットなど）、多くのノードに対する MSM の変更時のプッシュ操作、または高価な JCR クエリを使用してコンテンツをリアルタイムにレンダリングするなどがあります。 これらは、必ず他のテナントアプリケーションのパフォーマンスに影響を与えます。

### ログ {#logging}

AEMは、既製のインターフェイスを備え、共有開発シナリオでアドビが提供する強力なロガー設定を利用できます。 ブランドごとに個別のロガーをパッケージ名で指定することで、ある程度のログ分離をおこなうことができます。 レプリケーションや認証などのシステム全体の操作は引き続き一元的に記録されますが、非共有のカスタムコードは個別に記録でき、各ブランドの技術チームの監視やデバッグの作業が容易になります。

### バックアップと復元 {#backup-and-restore}

JCR リポジトリの性質上、従来のバックアップは、個々のコンテンツパスではなく、リポジトリ全体で動作します。 したがって、テナントごとに容易にバックアップを分離することはできません。 逆に、バックアップから復元すると、システム上のすべてのテナントのコンテンツとリポジトリノードがロールバックされます。 VLT などのツールを使用してターゲットコンテンツのバックアップを実行したり、別の環境でパッケージを構築して復元するコンテンツをチェリーすることは可能ですが、これらは可能です\
アプローチは、構成設定やアプリケーションロジックを容易に含まず、管理に煩雑な場合があります。

## セキュリティに関する考慮事項 {#security-considerations}

### ACL {#acls}

もちろん、アクセス制御リスト (ACL) を使用して、コンテンツの表示、作成、削除にアクセスできるユーザーを、ユーザーグループの作成と管理が必要なコンテンツパスに基づいて制御できます。 ACL とグループの管理の困難さは、各テナントが他のテナントに関する知識をゼロにすること、およびデプロイされたアプリケーションが共有リソースに依存しているかどうかに重点が置かれていることに依存します。 効率的な ACL、ユーザー、グループ管理を実現するために、必要な管理を行う一元化されたグループを使用して、効率とセキュリティを促進する方法で、これらのアクセス制御とプリンシパルが重複（または重複しない）するようにすることをお勧めします。
