---
title: マルチテナンシーと同時開発について
seo-title: マルチテナンシーと同時開発について
description: 'null'
seo-description: 'null'
uuid: 682093fe-ce55-4ef8-af10-99f7062f8b1b
discoiquuid: 0dfcdf39-7423-459f-8f35-ee5b4b829f2c
feature: connected-assets
topics: authoring, operations, sharing, publishing
audience: all
doc-type: article
activity: understand
version: 6.5
translation-type: tm+mt
source-git-commit: 99f2a8cdfe0b4f5f6f1a149d96affd2a9e8bcf75
workflow-type: tm+mt
source-wordcount: '2009'
ht-degree: 1%

---


# マルチテナンシーと同時開発について{#understanding-multitenancy-and-concurrent-development}

## 概要 {#introduction}

複数のチームが同じAEM環境にコードをデプロイする場合、他のチームの指示に従わずに、できる限り独立して作業できるようにする必要があります。 これらを完全に削除することはできませんが、これらの方法を使用すると、チーム間の依存関係を最小限に抑えることができます。 同時開発モデルが成功するには、開発チーム間での良好なコミュニケーションが重要です。

さらに、複数の開発チームが同じAEM環境で作業を行う場合、多テナント型の環境がある程度実現される可能性が高くなります。 AEM環境で複数のテナントをサポートしようとする際の実際的な考慮事項、特にガバナンス、運用、開発を管理する際に直面する課題について、多くが書かれています。 このホワイトペーパーでは、マルチテナント環境でのAEMの実装に関する技術的な問題のいくつかを説明しますが、これらの推奨事項の多くは、複数の開発チームを持つ組織に適用されます。

AEMは複数のサイトをサポートし、1つの環境に複数のブランドを展開できるのに対し、真のマルチテナンシーをオファーするわけではありません。 一部の環境構成およびシステムリソースは、常に、環境ーに展開されているすべてのサイトで共有されます。 このホワイトペーパーでは、これらの共有リソースとオファーの提案が及ぼす影響を最小限に抑え、これらの領域でのコミュニケーションとコラボレーションを合理化するためのガイダンスを提供します。

## メリットと課題{#benefits-and-challenges}

マルチテナント環境の実装には多くの課題があります。

有効なタイプには以下が含まれます。

* 技術的なその他の複雑さ
* 開発オーバーヘッドの増加
* 共有リソースに対する組織間の依存関係
* 運用の複雑さの増大

直面する課題にもかかわらず、マルチテナントアプリケーションの実行には次のような利点があります。

* ハードウェアコストの削減
* 今後のサイトのマーケティングに要する時間を短縮
* 将来のテナントの導入コストの削減
* ビジネス全体の標準的なアーキテクチャと開発プラクティス
* 共通のコードベース

ビジネスで真のマルチテナント性が必要で、他のテナントの知識がゼロで、共有コード、コンテンツ、一般的な作成者がない場合は、個別の作成者インスタンスが唯一の実行可能なオプションです。 開発作業の全体的な増加は、インフラストラクチャとライセンスのコストの削減と比較して、このアプローチが最適かどうかを判断する必要があります。

## 開発テクニック{#development-techniques}

### 依存関係の管理{#managing-dependencies}

Mavenプロジェクトの依存関係を管理する場合、すべてのチームで、サーバー上の特定のOSGiバンドルの同じバージョンを使用することが重要です。 Mavenプロジェクトが誤った管理下にある場合に何が悪くなるかを説明するため、以下の例を示します。

プロジェクトAはライブラリのバージョン1.0 foo；に依存しています。fooバージョン1.0は、サーバーへのデプロイメントに埋め込まれます。 プロジェクトBはライブラリのバージョン1.1 foo；に依存している。fooバージョン1.1は、それらのデプロイメントに埋め込まれています。

さらに、このライブラリでAPIがバージョン1.0から1.1の間に変更されたとします。この時点で、これら2つのプロジェクトの1つが正しく動作しなくなります。

この問題に対処するため、1つの親reactorプロジェクトのすべてのMavenプロジェクトの子を作成することをお勧めします。 このリアクタプロジェクトは、次の2つの目的を果たします。必要に応じて、すべてのプロジェクトの構築と配置を一緒に行うことができ、すべての子プロジェクトの依存関係宣言が含まれます。 親プロジェクトは依存関係とそのバージョンを定義しますが、子プロジェクトは必要な依存関係のみを宣言し、親プロジェクトからバージョンを継承します。

このシナリオでは、プロジェクトBで作業するチームがfooのバージョン1.1で機能を必要とする場合、開発環境では、この変更がプロジェクトAを壊すことがすぐに明らかになります。この時点で、チームはこの変更について話し合い、プロジェクトAを新しいバージョンと互換性を持たせるか、プロジェクトBの代替ソリューションを探すことができます。

これにより、チームがこの依存関係を共有する必要がなくなるわけではありません。単に問題を迅速かつ早期に強調するだけで、チームはリスクについて話し合い、ソリューションに関する同意を得ることができます。

### コードの重複を防ぐ{#preventing-code-duplication-nbsp-br}

複数のプロジェクトで作業を行う場合は、コードが重複しないようにすることが重要です。 コードの複製は、欠陥が発生する可能性、システムの変更に伴うコスト、およびコードベース全体の剛性を高めます。 重複を防ぐために、共通のロジックを、複数のプロジェクトで使用できる再利用可能なライブラリにリファクタリングします。

このニーズをサポートするには、すべてのチームが依存し、貢献できるコアプロジェクトの開発と保守をお勧めします。 その場合、この中核プロジェクトが個々のチームのプロジェクトに依存しないようにすることが重要です。これにより、コードの再利用を促進しながら、独立したデプロイ機能を実現できます。

コアモジュールで一般的に使用されるコードの例を以下に示します。

* 次のようなシステム全体の構成
   * OSGi 設定
   * サーブレットフィルター
   * ResourceResolverのマッピング
   * Sling変圧器パイプライン
   * エラー・ハンドラ(またはACS AEM Commons Error Page Handler1を使用)
   * 権限に依存するキャッシュの承認サーブレット
* ユーティリティクラス
* 中核的なビジネスロジック
* サードパーティの統合ロジック
* オーサリングUIオーバーレイ
* カスタムウィジェットなど、オーサリングに必要なその他のカスタマイズ
* ワークフローランチャー
* サイト間で共通するデザイン要素

*モジュラー型プロジェクトアーキテクチャ*

これにより、複数のチームが同じコードセットを依存し更新する必要がなくなります。 コアプロジェクトを作成することで、チーム間で共有されるコードベースのサイズが減少しましたが、共有リソースは不要になりません。

このコアパッケージに加えた変更がシステムの機能を妨げないように、シニア開発者または開発者チームに監視を維持することをお勧めします。 1つ目の方法は、このパッケージに対するすべての変更を管理する1つのチームを持つことです。もう1つは、これらのリソースで確認および結合されたプル要求をチームに送信させることです。 管理モデルを設計し、チームが合意し、開発者がそれに従うことが重要です。

## 導入範囲の管理(&amp;N) {#managing-deployment-scope}

異なるチームが同じリポジトリにコードをデプロイする場合は、互いの変更が上書きされないようにすることが重要です。 AEMは、コンテンツパッケージ（フィルター）を展開する際に、これを制御するメカニズムを備えています。 xmlファイルを参照してください。 フィルタ間で重複がないことが重要です。  xmlファイルに書き込みます。 この点を理解するために、次の適切に作成されたフィルタファイルと問題のあるフィルタファイルの例を参照してください。

/apps/my-会社と/apps/my-会社/my-site

/etc/clientlibs/my-会社と/etc/clientlibs/my-会社/my-site

/etc/designs/my-会社と/etc/designs/my-会社/my-site

各チームが、作業対象のサイトに対してフィルターファイルを明示的に設定した場合、各チームは、互いの変更を消去することなく、各自のコンポーネント、クライアントライブラリ、サイトデザインを個別に導入できます。

これは1つのサイトに固有ではないグローバルシステムパスなので、以下のサーブレットをコアプロジェクトに含める必要があります。ここで行った変更はチームに影響を与える可能性があるからです。

/apps/sling/servlet/errorhandler

### オーバーレイ {#overlays}

オーバーレイは、AEMの初期設定の機能を拡張または置き換えるために頻繁に使用されますが、オーバーレイを使用するとAEMアプリケーション全体に影響が及びます（つまり、すべてのテナントで機能の変更が利用できます）。 これは、テナントがオーバーレイに対する要件が異なる場合は、さらに複雑になります。 ビジネスグループは、AEMの管理コンソールの機能と外観に合わせて連携するのが理想的です。

様々な事業部門の間でコンセンサスが得られない場合、単にオーバーレイを使用しない方が解決策と考えられます。 代わりに、機能のカスタムコピーを作成し、テナントごとに異なるパスを使用して公開します。 これにより、各テナントは完全に異なるユーザーエクスペリエンスを得ることができますが、このアプローチにより、実装のコストと以降のアップグレード作業も増加します。

### ワークフローランチャー {#workflow-launchers}

AEMでは、ワークフローランチャーを使用して、リポジトリで指定された変更が行われた場合に、ワークフローの実行を自動的にトリガーします。 AEMには、新しいアセットや更新されたアセットに対してレンディションの生成やメタデータの抽出処理を実行するなど、あらかじめ用意されたいくつかのランチャーが用意されています。 これらのランチャーをそのまま残すことは可能ですが、マルチテナント環境では、テナントが異なるランチャーやワークフローモデルの要件を持つ場合、各テナントに対して個々のランチャーを作成して管理する必要があります。 これらのランチャーは、他のテナントのコンテンツを変更せずに、テナントの更新時に実行するように設定する必要があります。 これを簡単に行うには、テナントに固有の指定されたリポジトリパスにランチャーを適用します。

### バニティー URL {#vanity-urls}

AEMは、ページ単位で設定できるバニティURL機能を提供します。 マルチテナントシナリオでのこのアプローチの懸念事項は、AEMがこの方法で設定されたバニティURL間で一意性を確保できないことです。 2人の異なるユーザが異なるページに同じバニティパスを設定すると、予期しない動作が発生する場合があります。 このため、Apacheディスパッチャーインスタンスでmod_rewriteルールを使用することをお勧めします。これにより、アウトバウンド専用のリソースリゾルバールールと連携して設定の中心点を設定できます。

### コンポーネントグループ{#component-groups}

複数のオーサリンググループ用のコンポーネントとテンプレートを開発する場合は、componentGroupプロパティとallowedPathsプロパティを効果的に使用することが重要です。 これらをサイトデザインと共に効果的に活用することで、ブランドAの作成者はサイト用に作成されたコンポーネントとテンプレートのみを表示し、ブランドBの作成者は自分のコンポーネントのみを表示するようにできます。

### テスト {#testing}

優れたアーキテクチャとオープンなコミュニケーションチャネルは、サイトの予期しない領域に欠陥が導入されるのを防ぐのに役立ちますが、これらのアプローチはフールプルーフではありません。 このため、実稼働環境にリリースする前に、プラットフォームにデプロイされているものを完全にテストすることが重要です。 これには、各チームのリリースサイクルに関する調整が必要で、できるだけ多くの機能をカバーする自動テストスイートの必要性が強まります。 さらに、1つのシステムが複数のチームで共有されるので、パフォーマンス、セキュリティ、および負荷のテストがこれまで以上に重要になります。

## 操作に関する考慮事項{#operational-considerations}

### 共有リソース{#shared-resources}

AEMは単一のJVM内で実行されます。デプロイ済みのAEMアプリケーションは、AEMの通常の実行で既に使用されているリソースに加えて、本質的に相互にリソースを共有します。 JVMスペース内では、スレッドの論理的な分離は行われず、AEMで使用できるメモリ、CPU、ディスクi/oなどの有限のリソースも共有されます。 テナントがリソースを消費すると、他のシステムテナントにも影響が出ます。

### パフォーマンス {#performance}

AEMのベストプラクティスに従わない場合は、通常と考えられる範囲を超えてリソースを消費するアプリケーションを開発できます。 この例では、多くの重要なワークフロー操作（DAM Update Assetなど）、多数のノードに対するMSMのプッシュオン修正操作の使用、または高価なJCRクエリを使用してコンテンツをリアルタイムでレンダリングします。 これらは、必然的に、他のテナントアプリケーションのパフォーマンスに影響を与えます。

### ログ {#logging}

AEMは、堅牢なロガー設定のためのインターフェイスを追加設定なしで提供します。これは、共有開発シナリオでのアドビのメリットに使用できます。 ブランドごとに別々のロガーをパッケージ名で指定すると、ある程度のログ分離を行うことができます。 レプリケーションや認証など、システム全体の操作は引き続き一元的に記録されますが、非共有カスタムコードは個別に記録でき、各ブランドのテクニカルチームの監視とデバッグの作業が容易になります。

### バックアップと復元 {#backup-and-restore}

JCRリポジトリの特性により、従来のバックアップは、個々のコンテンツパスではなく、リポジトリ全体にわたって機能します。 したがって、テナントごとにバックアップを容易に分離することはできません。 逆に、バックアップから復元すると、システム上のすべてのテナントのコンテンツおよびリポジトリノードがロールバックされます。 VLTなどのツールを使用してコンテンツのバックアップをターゲット設定したり、別の環境ーにパッケージを構築して復元するコンテンツをチェリーピックすることは可能ですが、これらは\
アプローチは、構成設定やアプリケーションロジックを容易に網羅しておらず、管理に煩雑な場合があります。

## セキュリティに関する考慮事項 {#security-considerations}

### ACL {#acls}

もちろん、アクセス制御リスト(ACL)を使用して、表示グループの作成と管理が必要なコンテンツパスに基づいて、ユーザーにアクセスできるユーザーを制御できます。 ACLとグループの管理の困難さは、各テナントが他のユーザーの知識をゼロにすること、およびデプロイされたアプリケーションが共有リソースに依存しているかどうかに重点が置かれています。 効率的なACL、ユーザー、グループ管理を確保するために、必要な監視を持つ一元化されたグループを作成し、効率とセキュリティを向上させるために、これらのアクセス制御とプリンシパルが重複（または重複しない）ことを確認することをお勧めします。
