---
title: 第3章 — 高度なDispatcherキャッシュトピック
description: これは、AEMのキャッシュに関する3つのパートのシリーズのパート3です。 最初の2つの部分で、DispatcherのプレーンHTTPキャッシュとその制限事項に焦点を当てています。 ここでは、これらの制限を克服する方法に関するいくつかのアイデアを説明します。
feature: Dispatcher
topic: アーキテクチャ
role: Architect
level: Intermediate
source-git-commit: d9714b9a291ec3ee5f3dba9723de72bb120d2149
workflow-type: tm+mt
source-wordcount: '6189'
ht-degree: 0%

---


# 第3章 — 高度なキャッシュに関するトピック

*「コンピュータサイエンスには、難しい点が2つしかありません。キャッシュの無効化と命名について」*

 — フィル・カールトン

## 概要

これは、AEMのキャッシュに関する3つのパートのパート3です。 最初の2つの部分で、DispatcherのプレーンHTTPキャッシュとその制限事項に焦点を当てています。 ここでは、これらの制限を克服する方法に関するいくつかのアイデアを説明します。

## 一般的なキャッシュ

[このシリーズの第1](chapter-1.md) 章 [と第2章](chapter-2.md) では、主にDispatcherに焦点を当てています。私たちは、基本、制限、特定のトレードオフを行う必要がある場所を説明しました。

キャッシュの複雑さや複雑さは、Dispatcherに固有の問題ではありません。 一般的に、キャッシュは困難です。

ツールボックスにDispatcherを唯一のツールとして使用することは、実際には実際には制限されます。

この章では、キャッシュに関する考えをさらに広げ、Dispatcherの欠点の一部を克服する方法に関するアイデアを開発します。 銀の弾丸はありません。プロジェクトでトレードオフをする必要があります。 キャッシュと無効化の精度は常に複雑で、複雑さはエラーの可能性があることに注意してください。

これらの分野でトレードオフをする必要がある

* パフォーマンスと遅延
* リソース消費/CPU負荷/ディスク使用量
* 正確性/通貨/安定性/セキュリティ
* シンプルさ/複雑さ/コスト/メンテナンス性/エラー回答性

これらのディメンションは、かなり複雑なシステム内で相互にリンクされます。 簡単なif-thi-thatはありません。 システムをより簡単にすることで、より高速または低速にできます。 開発コストは抑えられますが、例えば、顧客が古いコンテンツを見たり、Webサイトの速度が遅いと不満を言ったりする場合は、ヘルプデスクのコストを増やすことができます。 これらの要因はすべて考慮され、互いにバランスを取る必要がある。 しかし、今はすでに良い考えを持つべきです。銀弾や「ベストプラクティス」は一つもない、というのは、悪い行いの多くと良い行いの数少ない、ということです。

## Chained Caching

### 概要

#### データフロー

サーバーからクライアントのブラウザーにページを配信する際に、多数のシステムとサブシステムをまたぎます。 注意深く見ると、ソースからドレインに対して取り出す必要のあるホップデータが多数あり、それぞれがキャッシュの候補となります。

![一般的なCMSアプリケーションのデータフロー](assets/chapter-3/data-flow-typical-cms-app.png)

*一般的なCMSアプリケーションのデータフロー*

<br> 

まず、ハードディスクに配置され、ブラウザーに表示する必要があるデータを使用して、ジャーニーを開始します。

#### ハードウェアとオペレーティングシステム

まず、ハードディスクドライブ(HDD)自体には、ハードウェアに組み込まれたキャッシュがあります。 第2に、ハードディスクをマウントするオペレーティングシステムは、頻繁にアクセスするブロックをキャッシュし、アクセスを高速化するために空きメモリを使用します。

#### コンテンツリポジトリ

次のレベルは、CRXまたはOak - AEMが使用するドキュメントデータベースです。 CRXとOakは、HDDへのアクセスの遅延を避けるために、データをメモリにキャッシュできるセグメントに分割します。

#### サードパーティデータ

大規模なWebインストールでは、サードパーティのデータも同じです。製品情報システム、顧客関係管理システム、レガシーデータベース、またはその他の任意のWebサービスからのデータ。 このデータは、必要に応じてソースから取り込む必要はありません。特に、頻繁に変更されないことがわかっている場合は取り込みません。 したがって、CRXデータベースで同期されていない場合は、キャッシュできます。

#### ビジネス層 — アプリ/モデル

通常、テンプレートスクリプトは、JCR APIを介してCRXからの生のコンテンツをレンダリングしません。 ほとんどの場合、ビジネスドメインオブジェクト内のデータのマージ、計算、変換を行う間にビジネスレイヤーが存在する可能性があります。 推測：これらの操作が高価な場合は、キャッシュを検討する必要があります。

#### マークアップフラグメント

モデルは、コンポーネントのマークアップのレンダリングのベースになります。 レンダリングされたモデルもキャッシュしないのはなぜですか？

#### Dispatcher、CDNおよびその他のプロキシ

Offは、レンダリングされたHTMLページをDispatcherに送信します。 既に説明したように、Dispatcherの主な目的は、HTMLページやその他のWebリソースを（名前にもかかわらず）キャッシュすることです。 リソースがブラウザーに到達する前に、キャッシュ可能なリバースプロキシと、キャッシュにも使用されるCDNを渡す場合があります。 クライアントは、プロキシ経由でのみWebアクセスを許可するオフィスに座る場合があります。また、そのプロキシはトラフィックを保存するだけでなく、キャッシュすることに決める場合もあります。

#### ブラウザーキャッシュ

最後ですが、それ以上 — ブラウザーもキャッシュします。 これは見落としやすい資産です。 ただし、キャッシュチェーン内で最も近く最も速いキャッシュです。 残念ながら — これはユーザー間で共有されるわけではありませんが、1人のユーザーの異なるリクエスト間で共有されます。

### キャッシュの場所と理由

それは、潜在的なキャッシュの長い連鎖です。 私たちは皆、古いコンテンツを見た問題に直面しています。 しかし、いくつの段階があるかを考えると、ほとんどの時間が全く機能しているのは奇跡です。

でもその鎖のどこに隠すのが妥当なの？ 最初に？ 最後に？ どこでも？ それは…多くの要因に依存します。 同じWebサイト内の2つのリソースでさえ、その質問に対する別の答えを求める可能性があります。

考慮に入れる要因を大まかに理解するために

**有効期間**  — オブジェクトに短い固有の有効期間（トラフィックデータの有効期間が天気データより短い場合）がある場合は、キャッシュの価値がない可能性があります。

**実稼動コスト —** オブジェクトの再生と配信にかかるコスト（CPUサイクルやI/Oの観点から見ると）。安いキャッシュが必要でない場合は、

**サイズ**  — 大きいオブジェクトは、キャッシュするリソースを増やす必要があります。これは限界的な要因になる可能性があり、利益とのバランスを取る必要があります。

**アクセス頻度**  — オブジェクトにほとんどアクセスしない場合、キャッシュが有効でない可能性があります。キャッシュから2回目にアクセスする前に、古くなったり無効になったりするだけです。 このようなアイテムは、メモリリソースをブロックするだけです。

**共有アクセス**  — 複数のエンティティが使用するデータは、チェーンの上にキャッシュする必要があります。実際には、キャッシュチェーンはチェーンではなく、ツリーです。 リポジトリ内の1つのデータを複数のモデルで使用できます。 これらのモデルは、複数のレンダリングスクリプトでHTMLフラグメントを生成するために使用できます。 これらのフラグメントは、複数のページに含まれ、複数のユーザーに、ブラウザーのプライベートキャッシュと共に配布されます。 したがって、「共有」とは、人々間だけでなく、ソフトウェアの断片間で共有することを意味します。 潜在的な「共有」キャッシュを見つけたい場合は、ツリーをルートに戻し、共通の親を見つけます。

**地理空間配布**  — ユーザーが世界中に配布されている場合、キャッシュの分散ネットワークを使用すると、待ち時間を削減できます。

**ネットワーク帯域幅と遅延**  — 遅延と言えば、お客様は誰で、どのような種類のネットワークを使用していますか。お客様は、旧世代のスマートフォンの3G接続を使用して、開発途上国のモバイル顧客である可能性があります。 小さなオブジェクトを作成して、ブラウザーのキャッシュにキャッシュすることを検討します。

このリストは、はるかに包括的ではありませんが、私たちは今、あなたがアイデアを得ると思います。

### チェーン・キャッシュの基本ルール

繰り返します。キャッシュは困難です。 以前のプロジェクトから抽出した基本的なルールを共有しましょう。これは、プロジェクトでの問題を回避するのに役立ちます。

#### 二重キャッシュの回避

最後の章で紹介した各レイヤーは、キャッシュチェーンの値を提供します。 コンピューティングサイクルを節約するか、データを消費者に近づけることで、 チェーンの複数の段階でデータをキャッシュするのは間違いではありませんが、次の段階のメリットとコストは必ず考慮する必要があります。 パブリッシュシステムの完全なページをキャッシュしても、通常は何のメリットもありません。これは、既にDispatcherでおこなわれるからです。

#### 無効化戦略の混合

以下の3つの基本的な無効化戦略があります。

* **TTL、有効期間：** オブジェクトは一定時間（「今後2時間」など）後に期限切れになります。
* **有効期限：** オブジェクトの有効期限は、定義された時刻に将来切れになります（例：「2019年6月10日午後5時」）。
* **イベントベース：** プラットフォームで発生したイベント（例：ページが変更され、アクティブ化された場合）によって、オブジェクトが明示的に無効化されます

異なるキャッシュレイヤで異なる戦略を使用できますが、「毒性」のあるものがいくつかあります。

#### イベントベースの無効化

![純粋なイベントベースの無効化](assets/chapter-3/event-based-invalidation.png)

*純粋なイベントベースの無効化：内側のキャッシュから外側のレイヤーへの無効化*

<br> 

純粋なイベントベースの無効化は、理論的に正確で最も正確なものを得るのが最も簡単で、理解しやすいものです。

簡単に言えば、キャッシュは、オブジェクトが変更された後に1つずつ無効化されます。

次のルールを1つ覚えておく必要があります。

常に内部から外部キャッシュに無効化します。 最初に外部キャッシュを無効にした場合、内部のコンテンツから古いコンテンツが再キャッシュされる可能性があります。 キャッシュが再び新しい時刻に何も推測しないでください。確かめてください。 最も良いのは、_内側のキャッシュを無効にした後に、外側のキャッシュ_&#x200B;の無効化をトリガーすることです。

これが理論です しかし実際には多くの謎が存在します イベントは、ネットワークを介して配布する必要があります。 実際には、これは、実装を最も困難にする無効化スキームです。

#### 自動 — 修復

イベントベースの無効化の場合は、コンティンジェンシープランが必要です。 無効化イベントが見つからない場合はどうなりますか？ 簡単な戦略は、一定時間後に無効化またはパージすることです。 そのため、そのイベントを見逃し、古いコンテンツを提供している可能性があります。 ただし、オブジェクトのTTLは数時間（日）のみの暗黙的な値を持ちます。 ついにシステムが自動修復します

#### 純粋なTTLベースの無効化

![非同期TTLベースの無効化](assets/chapter-3/ttl-based-invalidation.png)

*非同期TTLベースの無効化*

<br> 

それもごく一般的な計画です キャッシュの複数のレイヤーを積み重ね、各レイヤーは一定時間オブジェクトを提供する権利を持ちます。

簡単に実装できます。 残念ながら、データの有効寿命を予測するのは困難です。

![内側の物体のライフパンを延長する外側のチェース](assets/chapter-3/outer-cache.png)

*内側のオブジェクトの寿命を延長する外側のキャッシュ*

<br> 

上の図を考えてみましょう。 各キャッシュレイヤーは2分のTTLを導入します。 今 — TTL全体も2分で終わるでしょう？ まだ。 外側のレイヤが古くなる直前にオブジェクトを取り込むと、外側のレイヤは実際にオブジェクトの有効なライブ時間を延長します。 この場合、有効なライブ時間は2 ～ 4分です。 あなたはビジネス部門に同意したと考え、1日は耐えうる — そして4層のキャッシュを持っている。 各レイヤの実際のTTLは6時間以下にする必要があります。キャッシュミス率を増やす…

悪い計画だとは言っていません。 限界を知るべきです まずは素晴らしく簡単な戦略です サイトのトラフィックが増加した場合にのみ、より正確な戦略を検討できます。

*特定の日付を設定した無効化の時間の同期*

#### 有効期限に基づく無効化

内側のオブジェクトに特定の日付を設定し、それを外部のキャッシュに伝播すると、より予測可能な有効寿命が得られます。

![有効期限の同期](assets/chapter-3/synchronize-expiration-dates.png)

*有効期限の同期*

<br> 

ただし、すべてのキャッシュが日付を反映できるわけではありません。 外側のキャッシュが異なる有効期限を持つ2つの内側のオブジェクトを集計すると、厄介になる可能性があります。

#### イベントベースとTTLベースの無効化の混合

![イベントベースとTTLベースの戦略の混在](assets/chapter-3/mixing-event-ttl-strategies.png)

*イベントベースとTTLベースの戦略の混在*

<br> 

また、AEMの一般的なスキームは、内部キャッシュ（例えば、ほぼリアルタイムでイベントを処理できるメモリ内キャッシュ）でのイベントベースの無効化と、外部でのTTLベースのキャッシュ（明示的な無効化へのアクセス権がない場合）を使用します。

AEMの世界では、パブリッシュシステムのビジネスオブジェクトとHTMLフラグメントのメモリ内キャッシュがあります。このキャッシュは、基になるリソースが変更され、この変更イベントをDispatcherに伝達すると無効になり、イベントベースも機能します。 その前に、例えばTTLベースのCDNがあります。

Dispatcherの前にレイヤー（短い）TTLベースのキャッシュを持つと、通常は自動無効化の後に発生するスパイクを効果的に緩和できます。

#### 混合TTLとイベントベースの無効化

![TTLとイベントベースの無効化の混合](assets/chapter-3/toxic.png)

*毒性：TTLとイベントベースの無効化の混合*

<br> 

この組み合わせは毒性がある。 TTLまたは有効期限ベースのキャッシュの後に、とイベントベースのキャッシュを配置しないでください。 「pure-TTL」戦略で発生したスピルオーバー効果を覚えていますか？ ここでも同じ効果が見られる。 外部キャッシュの無効化イベントが既に発生した場合にのみ、再び発生しない可能性があります。これは、キャッシュされたオブジェクトの寿命を無限に広げることができます。

![TTLベースとイベントベースの組み合わせ：無限に波及](assets/chapter-3/infinity.png)

*TTLベースとイベントベースの組み合わせ：無限に波及*

<br> 

## 部分キャッシュとメモリ内キャッシュ

レンダリングプロセスのステージにフックして、キャッシュレイヤを追加できます。 リモートデータ転送オブジェクトの取得やローカルビジネスオブジェクトの作成から、単一のコンポーネントのレンダリングされたマークアップのキャッシュまで。 具体的な実装は、後のチュートリアルに残します。 しかし、既にこれらのキャッシュレイヤーのいくつかを自分で実装している予定かもしれません。 ですから、私たちができる最も少ないことは、基本的な原則、すなわち「了解事項」を紹介することです。

### 警告の単語

#### アクセス制御を尊重

ここで説明するテクニックは非常に強力で、各AEM開発者のツールボックスに&#x200B;_必ず_&#x200B;があります。 でもあまり興奮しないで、賢く使って。 オブジェクトをキャッシュに格納し、フォローアップリクエストで他のユーザーと共有することは、実際にはアクセス制御を回避することを意味します。 これは、通常、公開Webサイトに関する問題ではありませんが、アクセスを取得する前にユーザーがログインする必要がある場合に発生する可能性があります。

サイトのメインメニューのHTMLマークアップをメモリ内キャッシュに保存して、様々なページ間で共有するとします。 実際には、これは、部分的にレンダリングされたHTMLを保存する最適な例です。ナビゲーションの作成は、多くのページをトラバースする必要があるので、通常はコストがかかります。

同じメニュー構造をすべてのページで共有するのではなく、より効率的なすべてのユーザーと共有する必要があります。 しかし、待って…しかし、メニューには、特定のユーザーのグループに対してのみ予約されている項目がいくつかあるかもしれません。 その場合、キャッシュはもう少し複雑になります。

#### カスタムビジネスオブジェクトのみをキャッシュ

もしあれば、それが最も重要なアドバイスです。

>[!WARNING]
>
>自分で作成した不変の、浅くて参照先がないオブジェクトだけをキャッシュします。

どういう意味だ？

1. 他の人々の物体のライブサイクルを知らない。 リクエストオブジェクトへの参照を見て、それをキャッシュすることにします。 これで、リクエストが終了し、サーブレットコンテナは、次の受信リクエストに対してそのオブジェクトを再利用します。 その場合は、他のユーザーが、自分が独占的に制御できたと思っていたコンテンツを変更します。 却下しないでください — プロジェクトでこのようなことが起きています。 顧客が自分のデータではなく他の顧客データを見ていた。

2. オブジェクトが他の参照のチェーンによって参照されている限り、ヒープから削除できません。 参照する小さいと思われるオブジェクトをキャッシュに保持する場合、例えば画像の4MB表現を使用すると、メモリの漏洩に問題が生じる可能性が高くなります。 キャッシュは、弱い参照に基づいているはずです。 しかし、弱い参照は期待どおりに機能しません。 これは、メモリリークを生成し、メモリ不足エラーで終了する絶対的な最良の方法です。 そして — 異物のメモリのサイズは分からないでしょ？

3. 特にSlingでは、各オブジェクトを相互に適応させる（ほぼ）ことができます。 リソースをキャッシュに配置するとします。 次のリクエスト（アクセス権が異なる）は、そのリソースを取得し、それをresourceResolverまたはセッションに適応させて、アクセス権のない他のリソースにアクセスします。

4. AEMからリソースのシン「ラッパー」を作成する場合でも、それが独自で不変であっても、それをキャッシュしないでください。 ラップされたオブジェクトは参照（以前は禁止）で、鋭く見ると、基本的に最後の項目で説明したのと同じ問題を引き起こします。

5. キャッシュする場合は、プリミティブデータを独自のシャローオブジェクトにコピーして、独自のオブジェクトを作成します。 オブジェクトのツリーをキャッシュする場合など、参照を使用して独自のオブジェクト間をリンクすることができます。 これは問題ありません。ただし、同じリクエストで作成したオブジェクトのみをキャッシュし、他の場所からリクエストされたオブジェクトは（「自分の」オブジェクトの名前空間でも）ありません。 _オブジェクト_ をコピーして、キーをコピーします。また、リンクされたオブジェクトの構造全体を一度にパージし、構造への参照と参照の出入りを防ぎます。

6. はい — オブジェクトを不変に保ちます。 プライベートプロパティ（設定なし）。

多くのルールがありますが、それに従う価値があります。 経験があり、超スマートで、すべてをコントロール下に置いても。 あなたのプロジェクトの若い同僚は、ちょうど大学を卒業したばかりです。 彼はこうした落とし穴を全く知らない。 落とし穴が無ければ避けるべきことは無い。 簡潔で理解しやすいようにします。

### ツールとライブラリ

このシリーズは、の概念を理解し、ユースケースに最適なアーキテクチャを構築できるようにすることを目的としています。

特に、私たちは何のツールも推進していません。 でも、どう評価するかを示すヒントを与えてください。 例えば、AEMには、バージョン6.0以降の固定TTLを持つ単純な組み込みキャッシュがあります。これを使用しますか？ イベントベースのキャッシュがチェーン内でフォローするパブリッシュ上ではおそらくない(ヒント：Dispatcher )。 しかし、それは著者にとって妥当な選択によるかもしれない。 また、AdobeACSコモンによるHTTPキャッシュも検討する価値がある可能性があります。

または、[Ehcache](https://www.ehcache.org)のような成熟したキャッシュフレームワークに基づいて、独自のを構築します。 これを使用して、Javaオブジェクトとレンダリングされたマークアップ（`String`オブジェクト）をキャッシュできます。

単純な場合は、同時ハッシュマップの使用にも慣れるかもしれません。ツールまたはスキルのいずれかで、ここで制限をすばやく確認できます。 同時実行性は、名前とキャッシュと同じくらいマスターが困難です。

#### 参照

* [ACS Commonsのhttpキャッシュ  ](https://adobe-consulting-services.github.io/acs-aem-commons/features/http-cache/index.html)
* [Ehcacheキャッシュフレームワーク](https://www.ehcache.org)

### 基本用語

ここでは、あまり深いキャッシュ理論には入りませんが、私たちはいくつかのバズワードを提供する必要があると感じているので、あなたが良いジャンプスタートを得る。

#### キャッシュの削除

私たちは無効化とパージについて多く話した。 _キャッシュ_ の削除は、次の用語に関連しています。エントリを削除すると、そのエントリは使用できなくなります。ただし、エントリが古くなった場合ではなく、キャッシュがいっぱいになった場合に回避が発生します。 新しい（「より重要」な）項目は、古い（またはあまり重要でない）項目をキャッシュからプッシュします。 どのエントリを犠牲にする必要があるかは、ケースツーケースの決定です。 最も古いものや、ごくまれに使用されたものや、最後に長い間アクセスされたものを削除したい場合があります。

#### 予防的キャッシュ

プリエンプティブキャッシュとは、無効化または古いと見なされた瞬間に、新しいコンテンツを使用してエントリを再作成することを意味します。 もちろん、少数のリソースでのみ実行し、頻繁かつ即座にアクセスされることを確認します。 そうしないと、リクエストされない可能性のあるキャッシュエントリの作成時にリソースが無駄になります。 キャッシュエントリを事前に作成することで、キャッシュの無効化後に、リソースに対する最初の要求の待ち時間を短縮できます。

#### キャッシュウォーミング

キャッシュウォーミングは、プリエンプティブキャッシュと密接に関係しています。 ただし、実稼動システムにはその用語を使用しません。 時間の制約は前者より少ない。 無効化の直後に再キャッシュするのではなく、時間が許すと徐々にキャッシュをいっぱいにします。

例えば、ロードバランサーからパブリッシュ/Dispatcherの脚を取り出して更新します。 再統合する前に、最も頻繁にアクセスされるページを自動的にクロールして、再びキャッシュに取り込みます。 キャッシュが「ウォーム」の場合は、足をロードバランサーに再組み込みするのに十分です。

または、脚を一度に再組み込みする場合もありますが、通常の使用でキャッシュを暖める機会を得るために、足をその脚に向けてトラフィックをスロットルします。

また、実際のリクエストで実際にアクセスされた場合に、システムがアイドル状態になってから待ち時間を減らすために、アクセス頻度の低いページもキャッシュしたい場合もあります。

#### キャッシュオブジェクトのID、ペイロード、無効化の依存関係、TTL

一般に、キャッシュされたオブジェクト（「エントリ」）には、5つの主要なプロパティがあります。

#### キー

これは、を識別し、をオブジェクトにするプロパティです。 ペイロードを取得するか、キャッシュからパージします。 例えば、DispatcherはページのURLをキーとして使用します。 Dispatcherはページパスを使用しません。 これは、異なるレンダリングを区別するのに十分ではありません。 他のキャッシュは異なるキーを使用する場合があります。 後でいくつか例を見てみましょう。

#### 値/ペイロード

これは物体の宝箱です取り出したいデータです Dispatcherの場合は、ファイルコンテンツです。 ただし、Javaオブジェクトツリーにすることもできます。

#### TTL

TTLは既にカバーしています。 エントリが古く、配信されなくなるまでの時間。

#### 依存関係

これは、イベントベースの無効化に関連しています。 そのオブジェクトは何の元のデータに依存していますか？ 第1部では、真の正確な依存関係の追跡は複雑すぎると既に述べました。 しかし、システムの知識を持つことで、依存関係をよりシンプルなモデルで近似することができます。 古いコンテンツをパージするのに十分なオブジェクトを無効にします。不注意な場合は、必要以上に多くのコンテンツがパージされる可能性があります。 しかし、「すべてをパージ」を下に抑えようとしています。

どのオブジェクトが、各アプリケーションで他のどれが正規のものかによって異なります。 後で依存関係戦略を実装する方法の例をいくつか示します。

### HTMLフラグメントのキャッシュ

![別のページでのレンダリングされたフラグメントの再利用](assets/chapter-3/re-using-rendered-fragment.png)

*別のページでのレンダリングされたフラグメントの再利用*

<br> 

HTMLフラグメントのキャッシュは強力なツールです。 考え方は、コンポーネントによって生成されたHTMLマークアップをメモリ内キャッシュにキャッシュすることです。 なぜ私がそうすべきなのか？ Dispatcher内のページ全体のマークアップ（そのコンポーネントのマークアップを含む）をキャッシュしています。 我々は同意する。 1ページに1回だけ、実行できます。 そのマークアップはページ間で共有されません。

例えば、各ページの上にナビゲーションをレンダリングするとします。 マークアップは各ページで同じように表示されます。 ただし、Dispatcher内ではなく、各ページに対して繰り返しレンダリングします。 また、次の点に注意してください。自動無効化の後、すべてのページを再レンダリングする必要があります。 基本的に、同じコードを同じ結果で何百回も実行します。

アドビの経験から、ネストされたトップナビゲーションのレンダリングは非常にコストのかかる作業です。 通常は、ドキュメントツリーの適切な部分を移動してナビゲーション項目を生成します。 ナビゲーションタイトルとURLしか必要ない場合でも、ページはメモリに読み込む必要があります。 貴重な資源を詰まらせています 何度も何度も。

ただし、コンポーネントは多くのページで共有されます。 そして何かを共有することは、キャッシュを使うことを示すものです。 したがって、ナビゲーションコンポーネントが既にレンダリングされ、キャッシュされているかどうかを確認し、再レンダリングする代わりに、キャッシュ値を生成します。

その計画には2つの素晴らしい点が簡単に見逃される。

1. Java文字列をキャッシュしている。 Stringには参照元がなく、不変です。 上記の警告を考慮すると、これは非常に安全です。

2. 無効化も非常に簡単です。 Webサイトを変更した場合は常に、このキャッシュエントリを無効にする必要があります。 再構築は、1回だけ実行し、数百ページすべてで再利用されるので、比較的安価です。

これは、パブリッシュサーバーにとって大きな問題です。

### フラグメントキャッシュの実装

#### カスタムタグ

JSPをテンプレートエンジンとして使用した昔は、コンポーネントのレンダリングコードをラップするカスタムJSPタグを使用することが非常に一般的でした。

```
<!-- Pseudo Code -->

<myapp:cache
  key=' ${info.homePagePath} + ${component.path}'
  cache='main-navigation'
  dependency='${info.homePagePath}'>

… original components code ..

</myapp:cache>
```

よりもカスタムタグが本文をキャプチャしてキャッシュに書き込むか、本文の実行を防ぎ、代わりにキャッシュエントリのペイロードを出力します。

「キー」は、ホームページ上に表示されるコンポーネントのパスです。 現在のページではコンポーネントのパスを使用しません。これにより、ページごとに1つのキャッシュエントリが作成されるので、そのコンポーネントを共有する意図とは矛盾します。 また、コンポーネントの相対パス(`jcr:conten/mainnavigation`)だけを使用するのではなく、異なるサイトで異なるナビゲーションコンポーネントを使用できなくなります。

「キャッシュ」は、エントリを保存するインジケーターです。 通常、アイテムを格納するキャッシュは複数あります。 それぞれが少し異なる動作をする可能性があります。 したがって、格納される内容を区別することができます。最終的には文字列に過ぎません。

「依存関係」は、キャッシュエントリが依存するものです。 「メインナビゲーション」キャッシュには、ノード「dependency」の下に変更がある場合、それに応じたエントリをパージする必要があるというルールが含まれている場合があります。 したがって、キャッシュ実装は、変更を認識するために、自身をリポジトリ内のイベントリスナーとして登録し、キャッシュ固有のルールを適用して、無効化する必要があるものを見つけ出す必要があります。

上記は一例に過ぎない。 また、キャッシュのツリーを持つこともできます。 1番目のレベルを使用してサイト（またはテナント）を分割し、2番目のレベルを使用してコンテンツのタイプ（例えば、「メインナビゲーション」）に分岐します。これは、上の例のように、ホームページのパスを追加する必要があります。

ちなみに、この方法は、より最新のHTLベースのコンポーネントでも使用できます。 その後、HTLスクリプトの周りにJSPラッパーが作成されます。

#### コンポーネントフィルター

ただし、純粋なHTLアプローチでは、Slingコンポーネントフィルターを使用してフラグメントキャッシュを構築します。 未だに未だに見ていませんが、その問題に取り組むアプローチです。

#### Sling の動的インクルード

変更する環境（異なるページ）のコンテキストで一定（ナビゲーション）がある場合、フラグメントキャッシュが使用されます。

しかし、逆の場合もあります。比較的一定のコンテキスト（ほとんど変更されないページ）と、そのページ上で絶え間なく変化するフラグメント（ライブティッカーなど）があります。

この場合、[Sling Dynamic Includes](https://sling.apache.org/documentation/bundles/dynamic-includes.html)にチャンスを与えることができます。 要するに、これはコンポーネントフィルターで、動的コンポーネントを囲み、ページにコンポーネントをレンダリングする代わりに、参照を作成します。 この参照はAjax呼び出しにすることができます。そのため、コンポーネントがブラウザーに含まれ、周囲のページを静的にキャッシュできます。 または — または — Sling Dynamic Includeは、SSIディレクティブ（サーバー側インクルード）を生成できます。 このディレクティブはApacheサーバーで実行されます。 ESI - Edge Side Includeディレクティブは、ESIスクリプトをサポートするCDNやVanishを利用する場合にも使用できます。

![Sling動的インクルードを使用したリクエストのシーケンス図](assets/chapter-3/sequence-diagram-sling-dynamic-include.png)

*Sling動的インクルードを使用したリクエストのシーケンス図*

<br> 

SDIのドキュメントでは、動的コンポーネントを扱う際に、「*.nocache.html」で終わるURLのキャッシュを無効にする必要があると説明しています。

SDIの使用方法に関する別のオプションが表示される場合があります。インクルードのDispatcherキャッシュを&#x200B;_無効に_&#x200B;しない場合、Dispatcherは、前の章で説明したようにフラグメントキャッシュのように動作します。ページとコンポーネントフラグメントは、均等かつ独立してDispatcherにキャッシュされ、ページが要求されると、ApacheサーバーのSSIスクリプトによって結合されます。 そのため、（常に同じコンポーネントURLを使用している場合）メインナビゲーションなどの共有コンポーネントを実装できます。

それは理論上はうまくいくはずだ。 でも…

次の操作はおこなわないことをお勧めします。実際の動的コンポーネントのキャッシュをバイパスする機能は失われます。 SDIはグローバルに設定され、「pour-mans-fragment-cache」に対して行う変更も動的コンポーネントに適用されます。

SDIのドキュメントを慎重に調べることをお勧めします。 他にもいくつかの制限がありますが、SDIは場合によっては貴重なツールです。

#### 参照

* [docs.oracle.com — カスタムJSPタグの書き込み方法](https://docs.oracle.com/cd/E11035_01/wls100/taglib/quickstart.html)
* [Dominik Süß — コンポーネントフィルターの作成と使用](https://www.slideshare.net/connectwebex/prsentation-dominik-suess)
* [sling.apache.org - Sling Dynamic Includes](https://sling.apache.org/documentation/bundles/dynamic-includes.html)
* [helpx.adobe.com - AEMでのSling Dynamic Includeの設定](https://helpx.adobe.com/experience-manager/kt/platform-repository/using/sling-dynamic-include-technical-video-setup.html)


#### モデルのキャッシュ

![モデルベースのキャッシュ：2種類のレンダリングを持つ1つのビジネスオブジェクト](assets/chapter-3/model-based-caching.png)

*モデルベースのキャッシュ：2種類のレンダリングを持つ1つのビジネスオブジェクト*

<br> 

またナビゲーションで事件を見直そう。 各ページに同じマークアップのナビゲーションが必要と仮定していました。

でも、そうではないかもしれない。 ナビゲーション内で&#x200B;_現在のページ_&#x200B;を表す項目に対して、異なるマークアップをレンダリングする場合があります。

```
Travel Destinations

<ul class="maninnav">
  <li class="currentPage">Travel Destinations
    <ul>
      <li>Finland
      <li>Canada
      <li>Norway
    </ul>
  <li>News
  <li>About us
<ul>
```

```
News

<ul class="maninnav">
  <li>Travel Destinations
  <li class="currentPage">News
    <ul>
      <li>Winter is coming>
      <li>Calm down in the wild
    </ul>
  <li>About us
<is
```

これら2つは完全に異なるレンダリングです。 それでも、_ビジネスオブジェクト_（ナビゲーションツリー全体）は同じです。  _ビジネスオブジェクト_&#x200B;は、ツリー内のノードを表すオブジェクトグラフです。 このグラフは、メモリ内キャッシュに容易に格納できます。 ただし、このグラフには、自分で作成しなかったオブジェクト（特に現在はJCRノード）を含めたり、参照したりしないでください。

#### ブラウザーでのキャッシュ

既にブラウザでのキャッシュの重要性に触れ、多くの優れたチュートリアルがあります。 最後に（ブラウザーの場合）、DispatcherはHTTPプロトコルに従うWebサーバーに過ぎません。

しかし、理論にもかかわらず、私たちは他に見つけたことがなく、私たちが共有したいと思っている知識の一部を集めました。

基本的に、ブラウザーのキャッシュは、次の2つの方法で利用できます。

1. ブラウザーには、正確な有効期限を把握できるリソースがキャッシュされています。 その場合、リソースは再度リクエストされません。

2. ブラウザーにリソースがありますが、まだ有効かどうかは不明です。 その場合は、Webサーバー（この場合はDispatcher）に問い合わせます。 最後に配達してから変更された場合は、私に資料を下さい。 変更されていない場合、サーバは「304 - not changed」と答え、メタデータのみを送信しました。

#### デバッグ

Dispatcher設定をブラウザーのキャッシュ用に最適化する場合は、ブラウザーとWebサーバーの間でデスクトッププロキシサーバーを使用すると非常に役立ちます。 我々は、Karl von Randowの「Charles Web Debugging Proxy」を好む。

Charlesを使用すると、サーバーとの間で送信される要求と応答を読み取ることができます。 そして — HTTPプロトコルについて多くを学ぶことができます。 最新のブラウザーでもデバッグ機能がいくつか用意されていますが、デスクトッププロキシの機能はこれまでにないものです。 転送されたデータの操作、送信のスロットル、単一のリクエストの再生などを実行できます。 ユーザーインターフェイスは明確に配置され、非常に包括的です。

最も基本的なテストは、プロキシが間にある通常のユーザーとしてWebサイトを使用し、（/etc/...への）静的要求の数が時間の経過と共に少なくなっている場合にプロキシをチェックインすることです。

キャッシュされたリクエストはログに表示されないのに対し、一部のブラウザー組み込みデバッガーは引き続き「0ミリ秒」または「ディスクから」のリクエストを表示するので、プロキシの概要が明確になる場合があります。 これは正確で正確ですが、少し視野を曇らせる可能性があります。

次に、ドリルダウンして、転送したファイルのヘッダーを確認できます。例えば、「有効期限」のhttpヘッダーが正しいかどうかなどを確認できます。 if-modified-sinceヘッダーを設定してリクエストを再生し、サーバーが304または200応答コードで正しく応答するかどうかを確認できます。 非同期呼び出しのタイミングを観察し、セキュリティの前提をある程度テストすることもできます。 明示的に予期されないセレクターをすべて受け入れないように指示したのを覚えていますか？ ここで、URLとパラメーターを操作して、アプリケーションが正常に動作するかどうかを確認できます。

キャッシュをデバッグする際には、しないでください。

ブラウザーでページをリロードしないでください。

「ブラウザーのリロード」、_シンプルなリロード_&#x200B;および&#x200B;_forced-reload_(&quot;_shift-reload_&quot;)は、通常のページリクエストとは異なります。 単純な再読み込みリクエストはヘッダーを設定します

```
Cache-Control: max-age=0
```

また、Shiftキーを押しながらリロードボタンを押すと、通常リクエストヘッダーが設定されます

```
Cache-Control: no-cache
```

どちらのヘッダーも、似たように少し異なる効果を持ちますが、最も重要な点は、URLスロットからURLを開く場合やサイト上のリンクを使用する場合に、通常のリクエストとは完全に異なる点です。 通常のブラウジングでは、Cache-Controlヘッダーは設定されませんが、おそらくif-modified-sinceヘッダーです。

したがって、通常の閲覧動作をデバッグする場合は、次の操作を正確に行う必要があります。_通常は_&#x200B;参照します。 ブラウザーの再読み込みボタンを使用すると、設定でキャッシュ設定エラーを表示しないのが最適な方法です。

Charles Proxyを使用して、我々が何について話しているかを確認します。 はい — 開いている間に、そこでリクエストを再生できます。 ブラウザーから再読み込みする必要はありません。

## パフォーマンステスト

プロキシを使用すると、ページのタイミング動作を把握できます。 もちろん、それはパフォーマンステストではありません。  パフォーマンステストでは、ページを同時に要求する多数のクライアントが必要になります。

よくある間違いは、パフォーマンステストに含まれるページの数が非常に少なく、これらのページはDispatcherキャッシュからのみ配信されるというものです。

アプリケーションを実稼動システムに昇格させる場合、負荷はテストした負荷とは完全に異なります。

ライブシステムでは、テスト（ホームページと少数のコンテンツページ）で同じ数のページが均等に分散されているわけではありません。 ページ数がはるかに多く、リクエストの分布が非常に不均等です。 もちろん、ライブページをキャッシュから100%提供することはできません。公開システムからの無効化要求によって、貴重なリソースの大部分を自動的に無効化することができます。

ああはい — Dispatcherキャッシュを再構築する場合は、一握りのページのみをリクエストするか、それより大きい数をリクエストするかによって、パブリッシュシステムの動作も大きく異なることがわかります。 すべてのページが同様に複雑な場合でも、ページの数が役割を果たします。 連鎖するキャッシュについて何を言ったか覚えてる？ 常に同じページ数を要求する場合は、生データを持つ対応するブロックがハードドライブのキャッシュに格納されるか、ブロックがオペレーティングシステムによってキャッシュされる可能性が高くなります。 また、リポジトリが、対応するセグメントをメインメモリにキャッシュした可能性も高いです。 したがって、他のページが現在、様々なキャッシュから立ち退きをおこなっている場合よりも、再レンダリングの方が大幅に高速です。

キャッシュは困難であり、キャッシュに依存するシステムのテストも行われます。 では、より正確な現実のシナリオを実現するには、何ができるでしょうか？

複数のテストを実施する必要があると考えられ、ソリューションの品質の尺度として複数のパフォーマンスインデックスを提供する必要があります。

既にWebサイトがある場合は、リクエストの数とその分散方法を測定します。 同様の配分のリクエストを使用するテストのモデル化を試みます。 何かランダムさを加えても痛くはありません。 JSやCSSなどの静的リソースを読み込むブラウザーをシミュレートする必要はありません。これらは実際には関係ありません。 ブラウザーまたはDispatcherにキャッシュされ、読み込み量が大幅に増えることはありません。 しかし、参照画像は重要です。 古いログファイルで配布物を探し、類似のリクエストパターンをモデル化します。

次に、Dispatcherがキャッシュをまったくおこなわないテストを実行します。 それは最悪のシナリオです。 この最悪の状況下で、システムが不安定になっているピーク負荷を調べます。 また、必要に応じていくつかのDispatcher/パブリッシュの脚を取り出すことで、さらに悪化させる可能性があります。

次に、必要なキャッシュ設定をすべて「on」にして同じテストを実行します。 並列リクエストを徐々に増やして、キャッシュをウォーミングし、これらの最適な状況下でシステムがどの程度稼働できるかを確認します。

平均的なケースのシナリオとしては、Dispatcherを有効にした状態でテストを実行する場合と、一部の無効化が発生する場合があります。 cronjobによってstatfileにアクセスしたり、無効化要求を不規則な間隔でDispatcherに送信したりすることで、これをシミュレートできます。 また、自動的に無効化されていないリソースの一部は、時々パージすることを忘れないでください。

最後のシナリオは、無効化要求を増やし、負荷を増やすことで変更できます。

これは、単なる線形負荷テストよりも少し複雑ですが、ソリューションに対する信頼性が大幅に高まります。

君はその努力を恥ずかしがるかもしれない。 しかし、少なくとも、発行システムで最悪のテストを実行し、多数のページ（均等に配布）を使用してシステムの制限を確認します。 ベストケースシナリオの数を正しく解釈し、十分なヘッドルームをシステムにプロビジョニングしてください。